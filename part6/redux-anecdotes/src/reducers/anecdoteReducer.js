import {createSlice} from "@reduxjs/toolkit"
import anecdoteService from "../services/anecdote_service";

const getId = () => (100000 * Math.random()).toFixed(0)

const asObject = (anecdote) => {
    return {
        content: anecdote,
        id: getId(),
        votes: 0
    }
}

const anecdoteSlice = createSlice({
    name: 'anecdotes',
    initialState: [],
    reducers: {
        vote(state, action) {
            const id = action.payload
            const objToChange = state.find(obj => obj.id === id)
            const newObj = {
                ...objToChange,
                votes: objToChange.votes + 1
            }
            return state.map(obj => obj.id === id ? newObj : obj)
        },
        addAnecdote(state, action) {
            return state.concat(action.payload)
        },
        setAnecdotes(state, action) {
            return action.payload
        }
    }})


export const { vote, addAnecdote, setAnecdotes } = anecdoteSlice.actions

// ----- Thunks ----- //
// With a plain basic Redux store, you can only do simple synchronous updates by dispatching an action.
// Thunks (thunk functions) are recommended to write an async logic,
// and their execution is handled by the thunk middleware in the redux-thunk package/redux toolkit .
//
// In synchronous tasks, we dispatch an action, generated by action creator.
// In asynchronous tasks, we dispatch a thunk/thunk function, generated by thunk action creator.
// Thus, a thunk action creator is basically a function that wraps a thunk function and returns it.
//
// A thunk function always has (dispatch, getState) as input arguments,
// and you can use them inside the thunk as needed.


// thunk function creator
export const initializeAnecdotes = () => {
    // thunk function that accepts dispatch (and getState) as parameters
    return async (dispatch) => {
        const initialData = await anecdoteService.getAll()
        dispatch(setAnecdotes(initialData))
    }
}

export const createAnecdote = (anecdote) => {
    return async (dispatch) => {
        const newObj = asObject(anecdote)
        const returnedObj = await anecdoteService.create(newObj)
        dispatch(addAnecdote(returnedObj))
    }
}

export const updateVote = (anecdoteObj) => {
    return async dispatch => {
        const newObj = {
            ...anecdoteObj,
            votes: anecdoteObj.votes + 1
        }
        await anecdoteService.update(anecdoteObj.id, newObj)
        dispatch(vote(anecdoteObj.id))
    }
}

export default anecdoteSlice.reducer